# -*- coding: utf-8 -*-
"""nlp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16T-2UmvBcyOe8YS5hPRrmrmt5hFGOzWR
"""

import pandas as pd
import numpy as np

data = pd.read_csv('test_data.csv')

data['insight'] = ''

from yargy import Parser, rule, and_, not_
from yargy.interpretation import fact
from yargy.predicates import gram, is_capitalized
from yargy.relations import gnc_relation
from yargy.pipelines import morph_pipeline
from yargy.predicates import caseless, normalized, dictionary

list_of_text = []
polite_dialog = []
for i in range(max(data['dlg_id']) + 1):
    polite_dialog.append([False, False])
    list_of_text.append(list(data[data['role'] == 'manager'][data['dlg_id'] == i]['text']))

"""Для работы с диалогами я буду использовать yargy-парсер, который удобно использовать для извлечения сущностей по определенному правилу

# Приветствие

Для приветствия мы будем использовать morph_pipеline, в котором пропишем возможные синонимичные выражения.
"""

pipeline_hello = morph_pipeline([
    'Добрый день',
    'Привет',
    'Здравствуйте',
    "Приветствую",
    "Доброго времени суток",
    "Добрый вечер",
    "Доброе утро"
])

Hello = fact(
    'Hello',
    ['first']
)
gnc = gnc_relation()
HELLO_NAME = rule(
    pipeline_hello.interpretation(
        Hello.first
    ).match(gnc)

).interpretation(
    Hello
)

parser = Parser(HELLO_NAME)
no_hello = []
for i in range(len(list_of_text)):
    flag = False
    for j in range(len(list_of_text[i])):
        temp = parser.find(list_of_text[i][j])

        if temp != None:
            print(f"номер диалога:{i} и номер строчки:{j}")
            print(f"реплика:{(list_of_text[i][j])}")
            data.loc[(data.text == list_of_text[i][j]), 'insight'] = " greeting"
            polite_dialog[i][0] = True
            flag = True
            break
    if not flag:
        print(f"В диалоге {i} менеджер не поздоровался")

"""# Прощание"""

pipeline_bye = morph_pipeline([
    'До свидания',
    'Пока',
    'всего доброго',
    'всего хорошего',

])

Bye = fact(
    'Bye',
    ['first']
)
gnc = gnc_relation()
BYE_NAME = rule(
    pipeline_bye.interpretation(
        Bye.first
    ).match(gnc)

).interpretation(
    Bye
)

parser = Parser(BYE_NAME)

for i in range(len(list_of_text)):
    for j in range(len(list_of_text[i]) - 1, -1, -1):
        temp = parser.find(list_of_text[i][j])
        flag = False
        if temp != None:
            print(f"номер диалога:{i} и номер строчки:{j}")
            print(f"реплика:{(list_of_text[i][j])}")
            polite_dialog[i][1] = True
            data.loc[(data.text == list_of_text[i][j]), 'insight'] += "farewell"
            flag = True
            break
    if not flag:
        print(f"В диалоге {i} менеджер не попрощался")

"""Я считаю что в данном случае все хорошо можно считать как разновидность прощания всего хорошего

# проверка на требование к менеджеру "В каждом диалоге обязательно необходимо поздороваться и попрощаться с клиентом"
"""

for i in range(len(polite_dialog)):
    if (polite_dialog[i][0] and polite_dialog[i][1]):
        print(f"В диалоге {i} менеджер поздоровался и попрощался")
    elif (polite_dialog[i][0] and not polite_dialog[i][1]):
        print(f"В диалоге {i} менеджер поздоровался,но не попрощался")
    elif (not polite_dialog[i][0] and polite_dialog[i][1]):
        print(f"В диалоге {i} менеджер не поздоровался, но попрощался")
    elif (not polite_dialog[i][0] and not polite_dialog[i][1]):
        print(f"В диалоге {i} менеджер не поздоровался и не попрощался")

"""# название компании

для компании будем искать слово компания, после которого идут несколько существительных
"""

Company = fact(
    'Company',
    ['position', 'name']
)
Name = fact(
    'Name',
    ['first']
)

POSITION = morph_pipeline([
    'Компания'
])
NAME = gram('NOUN')
COMPANY = rule(rule(
    POSITION).interpretation(Company.position), rule(
    NAME,
    NAME.optional().repeatable()).interpretation(Company.name)
               ).interpretation(Company)

parser = Parser(COMPANY)
for i in range(len(list_of_text)):
    for j in range(len(list_of_text[i])):
        temp = parser.find(list_of_text[i][j])
        flag = False
        if temp != None:
            print(f"номер диалога:{i} и номер строчки:{j}")
            print(f"компания:{temp.fact.name}")
            data.loc[(data.text == list_of_text[i][j]), 'insight'] += f" company_name={temp.fact.name}"
            flag = True
            break
    if not flag:
        print(f"В диалоге {i} не было названия компании")

"""# имя менеджера

Для имени менеджера воспользуемся грамматикой имен и пайплайном с ключевыми словами которые идут перед представлением имени
"""

POSITION = morph_pipeline([
    'Меня зовут',
    "я",
    "это",
    "мое имя"
])

Person = fact(
    'Person',
    ['position', 'name']
)
Name = fact(
    'Name',
    ['first']
)
FIRST = and_(
    gram('Name'),
    not_(gram('Abbr')),
)

gnc = gnc_relation()
NAME = rule(
    FIRST.interpretation(
        Name.first
    ).match(gnc)

).interpretation(
    Name
)
PERSON = rule(rule(
    POSITION).interpretation(Person.position),
              NAME.interpretation(Person.name)
              ).interpretation(Person)

parser = Parser(PERSON)
for i in range(len(list_of_text)):
    for j in range(len(list_of_text[i])):
        temp = parser.find(list_of_text[i][j])
        flag = False
        if temp != None:
            print(f"номер диалога:{i} и номер строчки:{j}")
            print(f"имя:{temp.fact.name.first}")
            data.loc[(data.text == list_of_text[i][j]), 'insight'] += f" manager_name={temp.fact.name.first}"
            flag = True
            break
    if not flag:
        print(f"В диалоге {i} менеджер не представился")
data.to_csv("./result.csv")